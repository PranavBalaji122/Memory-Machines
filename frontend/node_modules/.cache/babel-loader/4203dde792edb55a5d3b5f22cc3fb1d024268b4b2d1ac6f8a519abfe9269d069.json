{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * useSentimentProcessor Hook\n * Makes API calls to backend for sentiment analysis and keyword extraction\n * Implements debouncing to only process final transcripts\n */\n\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport axios from 'axios';\n\n/**\n * Custom hook for processing text sentiment and extracting keywords\n * @returns {Object} Hook interface with sentiment data and processing function\n */\nfunction useSentimentProcessor() {\n  _s();\n  const [sentiment, setSentiment] = useState(null);\n  const [keywords, setKeywords] = useState([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Refs for debouncing and request management\n  const debounceTimer = useRef(null);\n  const abortController = useRef(null);\n  const lastProcessedText = useRef('');\n  const requestQueue = useRef([]);\n  const processingLock = useRef(false);\n\n  // Configuration\n  const BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8000';\n  const DEBOUNCE_DELAY = 500; // 500ms debounce\n  const MIN_TEXT_LENGTH = 10; // Minimum text length to process\n  const MAX_RETRIES = 3;\n  const RETRY_DELAY = 1000;\n\n  /**\n   * Process text through backend sentiment analysis\n   * Only processes final transcripts with debouncing\n   * @param {string} text - Text to analyze\n   * @param {boolean} isFinal - Whether this is a final transcript\n   */\n  const processText = useCallback(async (text, isFinal = true) => {\n    try {\n      // Only process final transcripts\n      if (!isFinal) {\n        console.log('Skipping interim transcript');\n        return;\n      }\n\n      // Skip if text is too short\n      if (!text || text.trim().length < MIN_TEXT_LENGTH) {\n        console.log('Text too short to process');\n        return;\n      }\n\n      // Skip if we've already processed this exact text\n      if (text === lastProcessedText.current) {\n        console.log('Text already processed');\n        return;\n      }\n\n      // Clear any pending debounce timer\n      if (debounceTimer.current) {\n        clearTimeout(debounceTimer.current);\n      }\n\n      // Debounce the request\n      debounceTimer.current = setTimeout(async () => {\n        // Add to queue if currently processing\n        if (processingLock.current) {\n          console.log('Adding to queue, currently processing');\n          requestQueue.current.push(text);\n          return;\n        }\n\n        // Set processing lock\n        processingLock.current = true;\n        setIsProcessing(true);\n        setError(null);\n\n        // Abort any pending request\n        if (abortController.current) {\n          abortController.current.abort();\n        }\n\n        // Create new abort controller for this request\n        abortController.current = new AbortController();\n        try {\n          console.log('Processing text for sentiment:', text.substring(0, 50) + '...');\n\n          // Make API request with retry logic\n          let attempt = 0;\n          let response = null;\n          while (attempt < MAX_RETRIES && !response) {\n            try {\n              response = await axios.post(`${BACKEND_URL}/process_text`, {\n                text: text\n              }, {\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                signal: abortController.current.signal,\n                timeout: 10000 // 10 second timeout\n              });\n            } catch (err) {\n              attempt++;\n              if (err.name === 'AbortError' || err.code === 'ECONNABORTED') {\n                console.log('Request was aborted');\n                break;\n              }\n              if (attempt < MAX_RETRIES) {\n                console.log(`Retry attempt ${attempt} after error:`, err.message);\n                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * attempt));\n              } else {\n                throw err;\n              }\n            }\n          }\n          if (response && response.data) {\n            const data = response.data;\n\n            // Validate response structure\n            if (data.sentiment && typeof data.sentiment === 'object') {\n              // Update sentiment state with smooth transition\n              setSentiment(prevSentiment => {\n                if (!prevSentiment) return data.sentiment;\n\n                // Smooth transition between sentiments\n                return {\n                  score: prevSentiment.score * 0.3 + data.sentiment.score * 0.7,\n                  type: data.sentiment.type,\n                  intensity: data.sentiment.intensity\n                };\n              });\n              console.log('Sentiment updated:', data.sentiment);\n            }\n\n            // Update keywords if present\n            if (data.keywords && Array.isArray(data.keywords)) {\n              setKeywords(data.keywords);\n              console.log('Keywords extracted:', data.keywords);\n            }\n\n            // Mark this text as processed\n            lastProcessedText.current = text;\n          }\n        } catch (err) {\n          console.error('Failed to process sentiment:', err);\n\n          // Handle specific error cases\n          let errorMessage = 'Failed to analyze sentiment';\n          if (err.response) {\n            // Server responded with error\n            if (err.response.status === 400) {\n              errorMessage = 'Invalid text format';\n            } else if (err.response.status === 500) {\n              errorMessage = 'Sentiment analysis service unavailable';\n            } else if (err.response.status === 503) {\n              errorMessage = 'Service temporarily unavailable';\n            } else {\n              var _err$response$data;\n              errorMessage = ((_err$response$data = err.response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.message) || errorMessage;\n            }\n          } else if (err.request) {\n            // Request made but no response\n            errorMessage = 'Cannot connect to backend. Please ensure the server is running.';\n          } else {\n            // Other errors\n            errorMessage = err.message || errorMessage;\n          }\n          setError(errorMessage);\n\n          // Don't clear existing sentiment on error\n          // This provides better UX by keeping last known state\n        } finally {\n          setIsProcessing(false);\n          processingLock.current = false;\n\n          // Process next item in queue if exists\n          if (requestQueue.current.length > 0) {\n            const nextText = requestQueue.current.shift();\n            setTimeout(() => {\n              processText(nextText, true);\n            }, 100);\n          }\n        }\n      }, DEBOUNCE_DELAY);\n    } catch (err) {\n      console.error('Unexpected error in processText:', err);\n      setError('An unexpected error occurred');\n      setIsProcessing(false);\n    }\n  }, [BACKEND_URL]);\n\n  /**\n   * Clear all sentiment and keyword data\n   */\n  const clearData = useCallback(() => {\n    setSentiment(null);\n    setKeywords([]);\n    setError(null);\n    lastProcessedText.current = '';\n    requestQueue.current = [];\n  }, []);\n\n  /**\n   * Get sentiment color for visualization\n   * @returns {Object} Color configuration\n   */\n  const getSentimentColor = useCallback(() => {\n    if (!sentiment) {\n      return {\n        primary: '#666666',\n        secondary: '#333333'\n      };\n    }\n    const colors = {\n      positive: {\n        primary: '#4CAF50',\n        secondary: '#81C784'\n      },\n      negative: {\n        primary: '#F44336',\n        secondary: '#EF5350'\n      },\n      neutral: {\n        primary: '#2196F3',\n        secondary: '#64B5F6'\n      }\n    };\n    return colors[sentiment.type] || colors.neutral;\n  }, [sentiment]);\n\n  /**\n   * Cleanup on unmount\n   */\n  useEffect(() => {\n    return () => {\n      // Cancel any pending requests\n      if (abortController.current) {\n        abortController.current.abort();\n      }\n\n      // Clear any pending timers\n      if (debounceTimer.current) {\n        clearTimeout(debounceTimer.current);\n      }\n    };\n  }, []);\n  return {\n    sentiment,\n    keywords,\n    isProcessing,\n    error,\n    processText,\n    clearData,\n    getSentimentColor\n  };\n}\n_s(useSentimentProcessor, \"HH4R2LapXG/WFDfaV6aY/ustRHg=\");\nexport default useSentimentProcessor;","map":{"version":3,"names":["useState","useRef","useCallback","useEffect","axios","useSentimentProcessor","_s","sentiment","setSentiment","keywords","setKeywords","isProcessing","setIsProcessing","error","setError","debounceTimer","abortController","lastProcessedText","requestQueue","processingLock","BACKEND_URL","process","env","REACT_APP_BACKEND_URL","DEBOUNCE_DELAY","MIN_TEXT_LENGTH","MAX_RETRIES","RETRY_DELAY","processText","text","isFinal","console","log","trim","length","current","clearTimeout","setTimeout","push","abort","AbortController","substring","attempt","response","post","headers","signal","timeout","err","name","code","message","Promise","resolve","data","prevSentiment","score","type","intensity","Array","isArray","errorMessage","status","_err$response$data","request","nextText","shift","clearData","getSentimentColor","primary","secondary","colors","positive","negative","neutral"],"sources":["/Users/pranavbalaji/Documents/Personal CS Projects/Memory Machines/sentiment-aura/frontend/src/hooks/useSentimentProcessor.js"],"sourcesContent":["/**\n * useSentimentProcessor Hook\n * Makes API calls to backend for sentiment analysis and keyword extraction\n * Implements debouncing to only process final transcripts\n */\n\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport axios from 'axios';\n\n/**\n * Custom hook for processing text sentiment and extracting keywords\n * @returns {Object} Hook interface with sentiment data and processing function\n */\nfunction useSentimentProcessor() {\n  const [sentiment, setSentiment] = useState(null);\n  const [keywords, setKeywords] = useState([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState(null);\n  \n  // Refs for debouncing and request management\n  const debounceTimer = useRef(null);\n  const abortController = useRef(null);\n  const lastProcessedText = useRef('');\n  const requestQueue = useRef([]);\n  const processingLock = useRef(false);\n  \n  // Configuration\n  const BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8000';\n  const DEBOUNCE_DELAY = 500; // 500ms debounce\n  const MIN_TEXT_LENGTH = 10; // Minimum text length to process\n  const MAX_RETRIES = 3;\n  const RETRY_DELAY = 1000;\n  \n  /**\n   * Process text through backend sentiment analysis\n   * Only processes final transcripts with debouncing\n   * @param {string} text - Text to analyze\n   * @param {boolean} isFinal - Whether this is a final transcript\n   */\n  const processText = useCallback(async (text, isFinal = true) => {\n    try {\n      // Only process final transcripts\n      if (!isFinal) {\n        console.log('Skipping interim transcript');\n        return;\n      }\n      \n      // Skip if text is too short\n      if (!text || text.trim().length < MIN_TEXT_LENGTH) {\n        console.log('Text too short to process');\n        return;\n      }\n      \n      // Skip if we've already processed this exact text\n      if (text === lastProcessedText.current) {\n        console.log('Text already processed');\n        return;\n      }\n      \n      // Clear any pending debounce timer\n      if (debounceTimer.current) {\n        clearTimeout(debounceTimer.current);\n      }\n      \n      // Debounce the request\n      debounceTimer.current = setTimeout(async () => {\n        // Add to queue if currently processing\n        if (processingLock.current) {\n          console.log('Adding to queue, currently processing');\n          requestQueue.current.push(text);\n          return;\n        }\n        \n        // Set processing lock\n        processingLock.current = true;\n        setIsProcessing(true);\n        setError(null);\n        \n        // Abort any pending request\n        if (abortController.current) {\n          abortController.current.abort();\n        }\n        \n        // Create new abort controller for this request\n        abortController.current = new AbortController();\n        \n        try {\n          console.log('Processing text for sentiment:', text.substring(0, 50) + '...');\n          \n          // Make API request with retry logic\n          let attempt = 0;\n          let response = null;\n          \n          while (attempt < MAX_RETRIES && !response) {\n            try {\n              response = await axios.post(\n                `${BACKEND_URL}/process_text`,\n                { text: text },\n                {\n                  headers: {\n                    'Content-Type': 'application/json',\n                  },\n                  signal: abortController.current.signal,\n                  timeout: 10000 // 10 second timeout\n                }\n              );\n              \n            } catch (err) {\n              attempt++;\n              \n              if (err.name === 'AbortError' || err.code === 'ECONNABORTED') {\n                console.log('Request was aborted');\n                break;\n              }\n              \n              if (attempt < MAX_RETRIES) {\n                console.log(`Retry attempt ${attempt} after error:`, err.message);\n                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * attempt));\n              } else {\n                throw err;\n              }\n            }\n          }\n          \n          if (response && response.data) {\n            const data = response.data;\n            \n            // Validate response structure\n            if (data.sentiment && typeof data.sentiment === 'object') {\n              // Update sentiment state with smooth transition\n              setSentiment(prevSentiment => {\n                if (!prevSentiment) return data.sentiment;\n                \n                // Smooth transition between sentiments\n                return {\n                  score: (prevSentiment.score * 0.3) + (data.sentiment.score * 0.7),\n                  type: data.sentiment.type,\n                  intensity: data.sentiment.intensity\n                };\n              });\n              \n              console.log('Sentiment updated:', data.sentiment);\n            }\n            \n            // Update keywords if present\n            if (data.keywords && Array.isArray(data.keywords)) {\n              setKeywords(data.keywords);\n              console.log('Keywords extracted:', data.keywords);\n            }\n            \n            // Mark this text as processed\n            lastProcessedText.current = text;\n          }\n          \n        } catch (err) {\n          console.error('Failed to process sentiment:', err);\n          \n          // Handle specific error cases\n          let errorMessage = 'Failed to analyze sentiment';\n          \n          if (err.response) {\n            // Server responded with error\n            if (err.response.status === 400) {\n              errorMessage = 'Invalid text format';\n            } else if (err.response.status === 500) {\n              errorMessage = 'Sentiment analysis service unavailable';\n            } else if (err.response.status === 503) {\n              errorMessage = 'Service temporarily unavailable';\n            } else {\n              errorMessage = err.response.data?.message || errorMessage;\n            }\n          } else if (err.request) {\n            // Request made but no response\n            errorMessage = 'Cannot connect to backend. Please ensure the server is running.';\n          } else {\n            // Other errors\n            errorMessage = err.message || errorMessage;\n          }\n          \n          setError(errorMessage);\n          \n          // Don't clear existing sentiment on error\n          // This provides better UX by keeping last known state\n        } finally {\n          setIsProcessing(false);\n          processingLock.current = false;\n          \n          // Process next item in queue if exists\n          if (requestQueue.current.length > 0) {\n            const nextText = requestQueue.current.shift();\n            setTimeout(() => {\n              processText(nextText, true);\n            }, 100);\n          }\n        }\n      }, DEBOUNCE_DELAY);\n      \n    } catch (err) {\n      console.error('Unexpected error in processText:', err);\n      setError('An unexpected error occurred');\n      setIsProcessing(false);\n    }\n  }, [BACKEND_URL]);\n  \n  /**\n   * Clear all sentiment and keyword data\n   */\n  const clearData = useCallback(() => {\n    setSentiment(null);\n    setKeywords([]);\n    setError(null);\n    lastProcessedText.current = '';\n    requestQueue.current = [];\n  }, []);\n  \n  /**\n   * Get sentiment color for visualization\n   * @returns {Object} Color configuration\n   */\n  const getSentimentColor = useCallback(() => {\n    if (!sentiment) {\n      return { primary: '#666666', secondary: '#333333' };\n    }\n    \n    const colors = {\n      positive: {\n        primary: '#4CAF50',\n        secondary: '#81C784'\n      },\n      negative: {\n        primary: '#F44336',\n        secondary: '#EF5350'\n      },\n      neutral: {\n        primary: '#2196F3',\n        secondary: '#64B5F6'\n      }\n    };\n    \n    return colors[sentiment.type] || colors.neutral;\n  }, [sentiment]);\n  \n  /**\n   * Cleanup on unmount\n   */\n  useEffect(() => {\n    return () => {\n      // Cancel any pending requests\n      if (abortController.current) {\n        abortController.current.abort();\n      }\n      \n      // Clear any pending timers\n      if (debounceTimer.current) {\n        clearTimeout(debounceTimer.current);\n      }\n    };\n  }, []);\n  \n  return {\n    sentiment,\n    keywords,\n    isProcessing,\n    error,\n    processText,\n    clearData,\n    getSentimentColor\n  };\n}\n\nexport default useSentimentProcessor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}